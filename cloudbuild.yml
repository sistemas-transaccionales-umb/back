steps:
  # Step 1: Construir la imagen Docker
  - name: 'gcr.io/cloud-builders/docker'
    id: 'build-image'
    args:
      - 'build'
      - '-t'
      - '${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_IMAGE_NAME}:${SHORT_SHA}'
      - '-t'
      - '${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_IMAGE_NAME}:latest'
      - '-f'
      - 'Dockerfile'
      - '.'
    timeout: '1200s' # 20 minutos para el build de Java

  # Step 2: Subir la imagen a Artifact Registry
  - name: 'gcr.io/cloud-builders/docker'
    id: 'push-image'
    args:
      - 'push'
      - '${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_IMAGE_NAME}:${SHORT_SHA}'
    waitFor: ['build-image']

  # Step 3: Subir la imagen latest
  - name: 'gcr.io/cloud-builders/docker'
    id: 'push-latest'
    args:
      - 'push'
      - '${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_IMAGE_NAME}:latest'
    waitFor: ['build-image']

  # Step 4: Desplegar a Cloud Run
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'deploy-cloud-run'
    entrypoint: gcloud
    args:
      - 'run'
      - 'deploy'
      - '${_SERVICE_NAME}'
      - '--image'
      - '${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_IMAGE_NAME}:${SHORT_SHA}'
      - '--region'
      - '${_REGION}'
      - '--platform'
      - 'managed'
      - '--allow-unauthenticated'
      - '--port'
      - '8080' # Puerto de Spring Boot
      - '--memory'
      - '1Gi' # Java necesita más memoria
      - '--cpu'
      - '2' # 2 vCPUs para mejor rendimiento
      - '--max-instances'
      - '10'
      - '--min-instances'
      - '0'
      - '--timeout'
      - '300' # 5 minutos de timeout
      # Variables de entorno para la base de datos (ajustar según tu configuración)
      - '--set-env-vars'
      - 'SPRING_PROFILES_ACTIVE=prod,SPRING_DATASOURCE_URL=${_DB_URL},SPRING_DATASOURCE_USERNAME=${_DB_USER},SPRING_DATASOURCE_PASSWORD=${_DB_PASSWORD},JWT_SECRET=${_JWT_SECRET},JWT_EXPIRATION=86400000'
      # Si usas Cloud SQL, descomentar y configurar:
      # - '--add-cloudsql-instances'
      # - '${_CLOUDSQL_INSTANCE}'
    waitFor: ['push-image', 'push-latest']

timeout: '2400s' # 40 minutos totales

options:
  machineType: 'E2_HIGHCPU_8' # Máquina más potente para build de Java
  logging: CLOUD_LOGGING_ONLY

images:
  - '${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_IMAGE_NAME}:${SHORT_SHA}'
  - '${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_IMAGE_NAME}:latest'

# Variables de sustitución con valores por defecto
substitutions:
  _REGION: 'us-east1'
  _REPOSITORY: 'haroldsoftware'
  _IMAGE_NAME: 'sistemas-transaccionales-backend'
  _SERVICE_NAME: 'sistemas-transaccionales-backend-service'
  # Variables de base de datos - CONFIGURAR ESTAS EN CLOUD BUILD TRIGGERS

  _DB_URL: 'spring.datasource.url=jdbc:mysql://root:UbQjCveFlUttNIlfUibaynJWctAPGZch@nozomi.proxy.rlwy.net:14993/railway?useUnicode=true&characterEncoding=utf8&useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC'
  _JWT_SECRET: '404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970'
  # Si usas Cloud SQL:
  # _CLOUDSQL_INSTANCE: 'project:region:instance'

# Comando manual para build y push local:
# docker buildx build -t sistemas-transaccionales-backend --platform linux/amd64 . && docker tag sistemas-transaccionales-backend us-east1-docker.pkg.dev/umb-sistemas-transaccionales/haroldsoftware/sistemas-transaccionales-backend:latest && docker push us-east1-docker.pkg.dev/umb-sistemas-transaccionales/haroldsoftware/sistemas-transaccionales-backend:latest
